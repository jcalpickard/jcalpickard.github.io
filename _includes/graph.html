<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    #network {
      width: 100%;
      height: 100%;
      border: 0px solid lightgray;
    }
    .graph-tooltip {
      position: absolute;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      display: none;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="network" style="width: 100%; height: 250px;"></div>
<div id="tooltip" class="graph-tooltip" style="display: none; position: absolute; background: #fff; border: 1px solid #ccc; padding: 10px; z-index: 1000;"></div>

<script type="text/javascript">
  function getCurrentPageNodeId(data) {
      const currentUrl = window.location.href;
      const node = data.nodes.find(node => currentUrl.includes(node.url));
      return node ? node.id : null;
    }

  function getEgocentricData(data, currentNodeId, degrees) {
    const nodes = new Set();
    const edges = new Set();
    const queue = [currentNodeId];
    const visited = new Set();

    for (let i = 0; i < degrees; i++) {
      const nextQueue = [];
      while (queue.length > 0) {
        const nodeId = queue.shift();
        if (!visited.has(nodeId)) {
          visited.add(nodeId);
          nodes.add(nodeId);
          data.links.forEach(link => {
            if (link.source === nodeId || link.target === nodeId) {
              edges.add(link);
              nextQueue.push(link.source === nodeId ? link.target : link.source);
            }
          });
        }
      }
      queue.push(...nextQueue);
    }

    return {
      nodes: data.nodes.filter(node => nodes.has(node.id)),
      edges: Array.from(edges)
    };
  }

  fetch('{{ "/assets/graph-data.json" | relative_url }}')
    .then(response => response.json())
    .then(data => {
      const currentNodeId = getCurrentPageNodeId(data);
      if (!currentNodeId) {
        console.error('Current page node ID not found in graph data.');
        return;
      }

    const egocentricData = getEgocentricData(data, currentNodeId, 3); // 3 degrees of separation

    const container = document.getElementById('network');
    const stages = {
      bruck: { color: '#CFD8DC', size: 20, borderWidth: 0 },
      tinkering: { color: '#B0BEC5', size: 20, borderWidth: 0 },
      roughingOut: { color: '#90A4AE', size: 20, borderWidth: 0 },
      moulding: { color: '#78909C', size: 20, borderWidth: 0 },
      detailing: { color: '#607D8B', size: 20, borderWidth: 0 }
    };

    egocentricData.nodes.forEach(node => {
        const stage = stages[node.stage];
        if (stage) {
          node.color = stage.color;
          node.size = stage.size;
          node.borderWidth = stage.borderWidth;
          node.tooltipContent = `<div>
                                <strong>${node.label}</strong>
                                <p>Tags: ${node.tags.join(', ')}</p>
                                </div>`;
          console.log(node); // Debugging line
      }
    });

      // Convert links to edges
      const edges = egocentricData.edges.map(link => ({
        from: link.source,
        to: link.target
      }));

      const networkData = {
        nodes: egocentricData.nodes,
        edges: edges
      };

      const options = {
        nodes: {
          shape: 'dot',
          font: {
            size: 12,
            color: '#000000'
          }
        },
        edges: {
          smooth: {
            enabled: true
          },
          width: 1.5
        },
        layout: {
          improvedLayout: true,
          hierarchical: {
            enabled: false,
            direction: 'LR',
            sortMethod: 'directed',
            levelSeparation: 150,
            nodeSpacing: 150
          }
        },
        interaction: {
          hover: true,
          navigationButtons: false,
          keyboard: false,
          tooltipDelay: 300
        },
        physics: {
          enabled: true,
          solver: 'barnesHut',
          barnesHut: {
            theta: 0.5,
            gravitationalConstant: -3500,
            centralGravity: 0.3,
            springLength: 95,
            springConstant: 0.04,
            damping: 0.1,
            avoidOverlap: 0.5
          },
          maxVelocity: 50,
          minVelocity: 0.1,
          stabilization: {
            iterations: 250
          }
        }
      };

      const network = new vis.Network(container, networkData, options);

      network.on("hoverNode", function (params) {
        const nodeId = params.node;
        const nodeData = egocentricData.nodes.find(node => node.id === nodeId);
          console.log(nodeData); // Debugging line
        tooltip.innerHTML = nodeData.tooltipContent;
        tooltip.style.display = "block";
        tooltip.style.left = params.event.pageX + "px";
        tooltip.style.top = params.event.pageY + "px";
      });

      network.on("blurNode", function () {
        tooltip.style.display = "none";
      });

      network.on('click', (params) => {
        if (params.nodes.length === 1) {
          const nodeId = params.nodes[0];
          const node = data.nodes.find(node => node.id === nodeId);
          if (node && node.url) {
            setTimeout(() => {
              window.location.href = node.url;
            }, 300);
          }
        }
      });
        // Center the graph on the current node
        network.once('stabilized', function () {
          network.focus(currentNodeId, {
          scale: 0.333, // Adjust the scale as needed
          animation: {
            duration: 1000,
            easingFunction: 'easeInOutQuad'
          }
        });
      });
    })
    .catch(error => {
      console.error('There has been a problem with your fetch operation:', error);
      // Handle the error, e.g., display an error message to the user
      const container = document.getElementById('network');
      container.innerHTML = 'Error loading the network graph. Please try again later.';
    });
  </script>
</body>